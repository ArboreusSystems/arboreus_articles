# Blockchain пример для Desktop/Mobile приложения.

Данный пример использования blockchain основан на опыте разработки десктоп-приложения базированного на ["Chromium Embedded Framework (CEF)"](https://bitbucket.org/chromiumembedded/cef). Впервые данных подход был применен в 2009 году. На сегодняшний момент, решения основанные на этом принципе используются во многих других приложениях, в том числе и для смартфонов различных типов и производителей.

Данный пример специально упрощен для иллюстрации принципа, по которому велась разработка и не является готовым решением. Готовое решение на прямую зависит от того, какая платформа используется и какие задачи должно решать приложение. Задача (idea) всегда будет определять цепь (chain) элементов, которые должны быть заблокированы (block).

Задача: задача разработать клиентское приложение строго привязанное к серверу данных использующего в качестве пользовательского интерфейса web-технологии. Иными словами это было, что-то типа браузера строго привязанного к одному сайту (серверу), с сильно увеличенным уровнем безопасности различными способами. Одним из таких способов была проверка целостности приложения при загрузке. Сейчас эту технологию называют blockchain, тогда, без малого 10 лет назад, это была просто проверка целостности.

Задача которую нужно реализовать при помощи blockchain - это обеспечить максимальную невозможность изменения файлов составляющих приложение (библиотеки, изображения, модули и т.д.), исключить возможность "инъекций" в модули приложения путем изменения библиотек максимально возможным способом.

Возвращаясь к blockchain - это зафиксированная цепь элементов составляющих целое. В данном случае целое (chain) - это приложение целиком, файлы относящиеся к этому приложению - это элементы цепи которую мы собираемся блокировать. В свою очередь файлы это байты связанные в единую последовательность (chain).

Иными словами задача может быть сформулирована так:  последовательность (chain) байт составляющих файлы, которые в свою очередь составляют приложения должна быть заблокирована (blocked) и неизменна.

![](https://raw.githubusercontent.com/ArboreusSystems/arboreus_articles/master/blockchain/bc_example_desktop_mobile_application/illustrations/blockchain_010.png)

Классический подход при компиляции приложения это когда все файлы имеющие отношение к приложению расположены в каком-то каталоге с последующим делением на подкаталоги если это необходимо.

Уникальным является сам файл и уникальность может быть вычислена  и зафиксирована при помощи функций MD5/4, но это будет константное значение которое всегда одинаковое. В случае с безопасностью любое статичное препятствие - потенциальная проблема, т.к. все что стоит неподвижно рано или поздно можно обойти.

Задача дополняется требованием об отсутствии константных значений при проверке целостности. Этого можно достичь при помощи объединения файлов необходимых для приложения в файлы коллекций, которые являются конкатенацией всех файлов в один организованный в определенной последовательности, где в начале файла (или в любом заранее определенном месте) расположена "адресная книга" которая указывает на то, где в теле конкатенированного файла расположено то или иное содержимое.

![](https://raw.githubusercontent.com/ArboreusSystems/arboreus_articles/master/blockchain/bc_example_desktop_mobile_application/illustrations/blockchain_011.png)

Последовательность конкатенации файлов может быть различной:

* целой: когда фалы конкатенируются один за одним и позиция файла (номер начального байта и номер конечного байта) хранятся в адресном пространстве
* фрагментной: когда файлы делятся на отдельные фрагменты и в произвольном порядке конкатенируются а в адресное пространство записываются позиции фрагментов 
* произвольная: это когда разработчик сам определяет как и что записывать в файл ресурсов

При компиляции приложения создаются файлы ресурсов, эталон которых сохраняется на сервере. И это является цепью (chain) которая заблокирована схемой конкатенации с сохранением её как protocol в "адресной книге" с последующим сохранением эталона на  сервере. При авторизации или загрузке приложения сервер читает цепь эталона в произвольном порядке и вычисляет MD5 от произвольной последовательности байтов и сохраняет это значение а клиентскому приложению отсылает только номера байтов которые нужно прочесть и вычислить значение MD5 на стороне клиента которое должно совпадать с тем которое сохранено на сервере.

![](https://raw.githubusercontent.com/ArboreusSystems/arboreus_articles/master/blockchain/bc_example_desktop_mobile_application/illustrations/blockchain_012.png)

Для увеличения безопасности данный процесс может итеративно повторяться несколько раз с различными последовательностями байтов для проверки.

Последовательность действий реализованная в приложении может выглядеть так:

* загрузчик приложения выполняет только чтение байтов и проверку приложения
* при прохождении авторизации, загрузчик, получает некий предкомпилированный модуль (в бинарном виде) с сервера, который встраивается в адресное пространство приложения и позволяет на основании "адресной книги" файла ресурсов устанавливать связи между модулями приложения, своего рода PROXY внутри приложения которое связывает элементы приложения между собой позволяя ему функционировать и при каждой загрузке адресное пространство данного PROXY новое.

Такой же принцип может быть использован для мониторинга памяти, когда память приложения представляется как цепь из элементов которая должна быть неизменна и в режиме реального времени и в произвольном порядке сканируется по принципу описанному выше.

Имплементация данного подхода в приложение сильно затрудняет возможность скомпрометировать приложение или как минимум сокращает время до момента распознания попытки злонамеренных действий.

Еще раз нужно обратить внимание, что это не финальная реализация  приложения, а только пример на основании которого можно создавать уникальное решение для какого-либо другого приложения. Перед использованием blockchain нужно четко понимать что есть элементы цепи (chain) которые должны быть зафиксированы (block).

Следите за обновлениями автора в [**Linkedin**](https://www.linkedin.com/in/alexandr-kirilov-3365b992/).

Следите за AR|BO|RE|US обновлениями в [**Twitter**](https://twitter.com/ArboreusSystems) в [**Linkedin**](www.linkedin.com/company/arboreus-systems/).